C51 COMPILER V9.60.7.0   PWM                                                               05/05/2025 14:47:47 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\Release\Objects\pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\pwm.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INCDIR
                    -(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\pwm.lst) OBJECT(.\Release\O
                    -bjects\pwm.obj)

line level    source

   1          #include "pwm.h"
   2          #include "time0.h"
   3          
   4          extern volatile bit flag_is_in_power_on; // æ˜¯å¦å¤„äºå¼€æœºç¼“å¯åŠ¨
   5          
   6          volatile u16 c_duty = 0;          // å½“å‰è®¾ç½®çš„å ç©ºæ¯”
   7          volatile u16 adjust_duty = 6000;  // æœ€ç»ˆè¦è°ƒèŠ‚æˆçš„å ç©ºæ¯”
   8          volatile u16 max_pwm_duty = 6000; // å­˜æ”¾å ç©ºæ¯”çš„ä¸Šé™å€¼
   9          // bit jump_flag = 0;
  10          // bit max_flag = 0; // æœ€å¤§å ç©ºæ¯”çš„æ ‡å¿—ä½
  11          
  12          // extern volatile bit flag_is_pin_9_vol_bounce; // æ ‡å¿—ä½ï¼Œ9è„šç”µå‹æ˜¯å¦å‘ç”Ÿäº†è·³åŠ¨ï¼ˆæ˜¯å¦å›
             - ä¸ºå‘åŠ¨æœºåŠŸç‡ä¸ç¨³å®šå¯¼è‡´è·³åŠ¨ï¼‰
  13          
  14          void pwm_init(void)
  15          {
  16   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1);
  17   1      #define STMR0_PEROID_VAL (SYSCLK / 8000 - 1)
  18   1          STMR0_PSC = STMR_PRESCALE_VAL(0x07);
  19   1          STMR0_PRH = STMR_PRD_VAL_H((STMR0_PEROID_VAL >> 8) & 0xFF);
  20   1          STMR0_PRL = STMR_PRD_VAL_L((STMR0_PEROID_VAL >> 0) & 0xFF);
  21   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  22   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  23   1          STMR_PWMVALA |= STMR_0_PWMVALA(0x1);
  24   1      
  25   1          STMR_CNTMD |= STMR_0_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  26   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  27   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); //
  28   1          STMR_CNTEN |= STMR_0_CNT_EN(0x1);   // ä½¿èƒ½
  29   1          STMR_PWMEN |= STMR_0_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  30   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03);
  31   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x01);
  32   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x03);
  33   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x01);
  34   1          FOUT_S14 = GPIO_FOUT_AF_FUNC;      // AFåŠŸèƒ½è¾“å‡º
  35   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  36   1      }
  37          
  38          // 14è„šçš„PWMè°ƒèŠ‚
  39          void set_pwm_duty(void)
  40          {
  41   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((c_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  42   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((c_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  43   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                    // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  44   1      }
  45          
  46          /*
  47              æ»¤æ³¢ã€åˆ¤æ–­ç”µå‹æ˜¯å¦æœ‰è·³åŠ¨ï¼Œä¸€æ®µæ—¶é—´å†…ç”µå‹æµ®åŠ¨è¿‡å¤§ï¼Œ
  48              æ‰€ä½¿ç”¨åˆ°çš„è¿™äº›å˜é‡
  49          */
  50          static u16 t_count = 0;
  51          static u16 t_adc_max = 0;    // å­˜æ”¾ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„æœ€å¤§adå€¼
  52          static u16 t_adc_min = 4096; // å­˜æ”¾ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„æœ€å°adå€¼
C51 COMPILER V9.60.7.0   PWM                                                               05/05/2025 14:47:47 PAGE 2   

  53          static u8 over_drive_status = 0;
  54          #define OVER_DRIVE_RESTART_TIME (30)
  55          
  56          static volatile u16 filter_buff_2[270] = {0}; // ç”¨äºæ»¤æ³¢çš„æ•°ç»„
  57          static volatile u16 buff_index_2 = 0;         // ç”¨äºæ»¤æ³¢çš„æ•°ç»„ä¸‹æ ‡
  58          
  59          // ç”µæºç”µå‹ä½äº170V-AC,å¯åŠ¨ä½å‹ä¿æŠ¤ï¼Œç”µæºç”µå‹é«˜äº170V-ACï¼Œå…³é—­ä½å‹ä¿æŠ¤
  60          // æ¸©åº¦æ­£å¸¸ï¼Œæ‰ä¼šè¿›å…¥åˆ°è¿™é‡Œ
  61          void according_pin9_to_adjust_pwm(void)
  62          {
  63   1      #define ADC_DEAD_ZONE_NEAR_170VAC (30) // 170VACé™„è¿‘çš„adå€¼æ­»åŒº
  64   1          static volatile u16 filter_buff[32] = {
  65   1              0xFFFF,
  66   1          };
  67   1          static volatile u8 buff_index = 0;
  68   1          static volatile u8 flag_is_sub_power = 0;  // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å‡åŠŸç‡ï¼ˆçŠ¶æ€æœºï¼‰
  69   1          static volatile u8 flag_is_sub_power2 = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å‡åŠŸç‡
  70   1          static volatile bit flag_is_add_power = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å¢åŠŸç‡
  71   1      
  72   1          volatile u32 adc_pin_9_avg = 0; // å­˜æ”¾å¹³å‡å€¼
  73   1      
  74   1          if (filter_buff[0] == 0xFFFF) // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ£€æµ‹ï¼Œè®©æ•°ç»„å†…æ‰€æœ‰å…ƒç´ éƒ½å˜ä¸ºç¬¬ä¸€æ¬¡
             -é‡‡é›†çš„æ•°æ®ï¼Œæ–¹ä¾¿å¿«é€Ÿä½œå‡ºå˜åŒ–
  75   1          {
  76   2              u16 i = 0;
  77   2              for (; i < ARRAY_SIZE(filter_buff); i++)
  78   2              {
  79   3                  filter_buff[i] = adc_val_pin_9;
  80   3              }
  81   2              for (i = 0; i < 270; i++)
  82   2              {
  83   3                  filter_buff_2[i] = adc_val_pin_9;
  84   3              }
  85   2          }
  86   1          else
  87   1          {
  88   2              u16 temp = filter_buff[buff_index];
  89   2              temp += adc_val_pin_9;
  90   2              temp >>= 1;
  91   2              filter_buff[buff_index] = temp;
  92   2              buff_index++;
  93   2              if (buff_index >= ARRAY_SIZE(filter_buff))
  94   2              {
  95   3                  buff_index = 0;
  96   3              }
  97   2          }
  98   1      
  99   1          { // å–å‡ºæ•°ç»„å†…çš„æ•°æ®ï¼Œè®¡ç®—å¹³å‡å€¼
 100   2              u16 i = 0;
 101   2              for (; i < ARRAY_SIZE(filter_buff); i++)
 102   2              {
 103   3                  adc_pin_9_avg += filter_buff[i];
 104   3              }
 105   2      
 106   2              // adc_pin_9_avg /= ARRAY_SIZE(filter_buff);
 107   2              adc_pin_9_avg >>= 5;
 108   2          } // å–å‡ºæ•°ç»„å†…çš„æ•°æ®ï¼Œè®¡ç®—å¹³å‡å€¼
 109   1      
 110   1          // åœ¨å‰é¢æ»¤æ³¢çš„åŸºç¡€ä¸Šå†è¿›è¡Œä¸€æ¬¡æ»¤æ³¢
 111   1          filter_buff_2[buff_index_2] = adc_pin_9_avg;
 112   1          buff_index_2++;
 113   1          if (buff_index_2 >= 270)
C51 COMPILER V9.60.7.0   PWM                                                               05/05/2025 14:47:47 PAGE 3   

 114   1          {
 115   2              buff_index_2 = 0;
 116   2          }
 117   1      
 118   1      #if USE_MY_DEBUG
                  // printf(",b=%lu,", adc_pin_9_avg);
              #endif
 121   1      
 122   1          // if (adc_pin_9_avg > t_adc_max)
 123   1          //     t_adc_max = adc_pin_9_avg;
 124   1          // if (adc_pin_9_avg < t_adc_min)
 125   1          //     t_adc_min = adc_pin_9_avg;
 126   1          // if (t_count < 270)
 127   1          // {
 128   1          //     t_count++;
 129   1          //     if (t_count == 270)
 130   1          //     {
 131   1          //         if ((t_adc_max - t_adc_min) > 80 && t_adc_max > 2228)
 132   1          //         { // ç”µå‹æ³¢åŠ¨
 133   1          //             over_drive_status = OVER_DRIVE_RESTART_TIME;
 134   1          //         }
 135   1          //         else
 136   1          //         {
 137   1          //             if (over_drive_status)
 138   1          //                 over_drive_status--;
 139   1          //         }
 140   1          //         t_count = 0;
 141   1          //         t_adc_max = 0;
 142   1          //         t_adc_min = 4096;
 143   1          //     }
 144   1          // }
 145   1          {
 146   2              u16 i = 0;
 147   2              t_adc_max = 0;
 148   2              t_adc_min = 4096;
 149   2              for (; i < 270; i++)
 150   2              {
 151   3                  if (filter_buff_2[i] > t_adc_max)
 152   3                      t_adc_max = filter_buff_2[i];
 153   3                  if (filter_buff_2[i] < t_adc_min)
 154   3                      t_adc_min = filter_buff_2[i];
 155   3                  if ((t_adc_max - t_adc_min) > 80)
 156   3                  { // ç”µå‹æ³¢åŠ¨
 157   4                      over_drive_status = OVER_DRIVE_RESTART_TIME;
 158   4                  }
 159   3                  else
 160   3                  {
 161   4                      if (over_drive_status)
 162   4                          over_drive_status--;
 163   4                  }
 164   3              }
 165   2          }
 166   1      
 167   1          if (adc_pin_9_avg >= (1645 /*1475*/ + ADC_DEAD_ZONE_NEAR_170VAC) || (flag_is_add_power && adc_pin_9_av
             -g > (1645 /*1475*/ + ADC_DEAD_ZONE_NEAR_170VAC))) // å¤§äº 170VAC
 168   1          {
 169   2              // å¤§äº170VACï¼Œæ¢å¤100%å ç©ºæ¯”ï¼Œä½†æ˜¯ä¼˜å…ˆçº§æ¯” "9è„šç”µå‹æ£€æµ‹åˆ°å‘é€æœºåŠŸç‡ä¸ç
             -¨³å®šï¼Œè¿›è€Œé™åŠŸç‡" ä½
 170   2              flag_is_sub_power = 0;
 171   2              flag_is_sub_power2 = 0;
 172   2              flag_is_add_power = 1;
 173   2      #if 0
C51 COMPILER V9.60.7.0   PWM                                                               05/05/2025 14:47:47 PAGE 4   

                      // åˆ¤æ–­æ˜¯å¦å˜åŒ–PWM
                      if (adc_pin_9_avg > ADC_VAL_WHEN_UNSTABLE) // 9è„šç”µå‹è¶…è¿‡ä¸ç¨³å®šé˜ˆå€¼å¯¹åº”çš„ç”µå‹
                      {
                          if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
                          {
                              flag_is_pwm_sub_time_comes = 0;
                              // è¿‡è½½ pwm--
                              // if (adjust_duty > PWM_DUTY_50_PERCENT)
                              if (adjust_duty > PWM_DUTY_30_PERCENT)
                              {
                                  adjust_duty -= 1;
                              }
                              else
                              {
                                  // adjust_duty = PWM_DUTY_50_PERCENT;
                                  adjust_duty = PWM_DUTY_30_PERCENT;
                              }
                          }
                      }
                      else if (adc_pin_9_avg < (ADC_VAL_WHEN_UNSTABLE - 50))
                      {
                          // æœªæ»¡è½½ pwm++
                          if (flag_is_pwm_add_time_comes) // pwmå ç©ºæ¯”é€’å¢æ—¶é—´åˆ°æ¥
                          {
                              flag_is_pwm_add_time_comes = 0;
                              if (adjust_duty < 6000)
                              {
                                  adjust_duty++;
                              }
                          }
                      }
              #else
 206   2              if (over_drive_status == OVER_DRIVE_RESTART_TIME) // 9è„šç”µå‹è¶…è¿‡ä¸ç¨³å®šé˜ˆå€¼å¯¹åº”çš„ç”µå
             -‹
 207   2              {
 208   3                  over_drive_status -= 1;
 209   3                  if (adjust_duty > PWM_DUTY_50_PERCENT)
 210   3                  {
 211   4                      // adjust_duty -= 300; // å˜åŒ–å¤ªå¤§ï¼Œä¼šé€ æˆç¯å…‰é—ªçƒ
 212   4                      adjust_duty -= 1;
 213   4                  }
 214   3      
 215   3                  if (adjust_duty < PWM_DUTY_50_PERCENT)
 216   3                  {
 217   4                      adjust_duty = PWM_DUTY_50_PERCENT;
 218   4                  }
 219   3              }
 220   2              else if (over_drive_status == 0)
 221   2              {
 222   3                  // æœªæ»¡è½½ pwm++
 223   3                  if (flag_is_pwm_add_time_comes) // pwmå ç©ºæ¯”é€’å¢æ—¶é—´åˆ°æ¥
 224   3                  {
 225   4                      flag_is_pwm_add_time_comes = 0;
 226   4                      if (adjust_duty < PWM_DUTY_100_PERCENT)
 227   4                      {
 228   5                          adjust_duty++;
 229   5                      }
 230   4                  }
 231   3              }
 232   2      #endif
 233   2          }
 234   1          else if (adc_pin_9_avg > (1475) && (adc_pin_9_avg <= (1645 /*1475*/) || flag_is_sub_power == 4)) // å°
C51 COMPILER V9.60.7.0   PWM                                                               05/05/2025 14:47:47 PAGE 5   

             -äº 170VAC
 235   1          {
 236   2              // é”å®šæœ€å¤§çš„å ç©ºæ¯”ä¸º50%ï¼Œå¹¶ä¸”ç»™ç›¸åº”æ ‡å¿—ä½ç½®ä¸€
 237   2              if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
 238   2              {
 239   3                  flag_is_pwm_sub_time_comes = 0;
 240   3                  // if (flag_is_sub_power == 0)
 241   3                  //     flag_is_sub_power = 1;
 242   3                  // else if (flag_is_sub_power == 1)
 243   3                  //     flag_is_sub_power = 2;
 244   3                  if (flag_is_sub_power < 4)
 245   3                      flag_is_sub_power++;
 246   3      
 247   3                  flag_is_sub_power2 = 0;
 248   3                  flag_is_add_power = 0;
 249   3      
 250   3                  if (adjust_duty > PWM_DUTY_50_PERCENT)
 251   3                  // if (adjust_duty > PWM_DUTY_30_PERCENT)
 252   3                  {
 253   4                      adjust_duty -= 2;
 254   4                  }
 255   3                  else if (adjust_duty < PWM_DUTY_50_PERCENT)
 256   3                  {
 257   4                      adjust_duty++;
 258   4                  }
 259   3                  else
 260   3                  {
 261   4                      adjust_duty = PWM_DUTY_50_PERCENT;
 262   4                  }
 263   3              }
 264   2          }
 265   1          else if (adc_pin_9_avg <= (1475) || (flag_is_sub_power2)) // å°äº 170VAC
 266   1          {
 267   2              // é”å®šæœ€å¤§çš„å ç©ºæ¯”ä¸º50%ï¼Œå¹¶ä¸”ç»™ç›¸åº”æ ‡å¿—ä½ç½®ä¸€
 268   2              if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
 269   2              {
 270   3                  flag_is_pwm_sub_time_comes = 0;
 271   3                  // if (flag_is_sub_power2 < 4)
 272   3                  //     flag_is_sub_power2++;
 273   3      
 274   3                  flag_is_sub_power2 = 1;
 275   3                  flag_is_sub_power = 0;
 276   3                  flag_is_add_power = 0;
 277   3      
 278   3                  // if (adjust_duty > PWM_DUTY_50_PERCENT)
 279   3                  if (adjust_duty > PWM_DUTY_30_PERCENT)
 280   3                  {
 281   4                      adjust_duty -= 2;
 282   4                  }
 283   3                  else
 284   3                  {
 285   4                      // adjust_duty = PWM_DUTY_50_PERCENT;
 286   4                      adjust_duty = PWM_DUTY_30_PERCENT;
 287   4                  }
 288   3              }
 289   2          }
 290   1      }
 291          
 292          // æ ¹æ®9è„šçš„ç”µå‹æ¥è®¾å®š16è„šçš„ç”µå¹³ï¼ˆè¿‡å‹ä¿æŠ¤ï¼‰
 293          void according_pin9_to_adjust_pin16(void)
 294          {
 295   1          // å½“9è„šç”µå‹é«˜äº 3.6 Væ—¶ï¼Œ16è„šè¾“å‡º1KHz é«˜ç”µå¹³,ç”¨äºæ§åˆ¶Q2çš„å¯¼é€šï¼ˆç”¨äºå…³æœºï¼‰ã
C51 COMPILER V9.60.7.0   PWM                                                               05/05/2025 14:47:47 PAGE 6   

             -€‚
 296   1          // if (adc_val_pin_9 >= 3511)
 297   1          // {
 298   1          //     P14 = 1;
 299   1          // }
 300   1          // else if (adc_val_pin_9 <= 3511 - 40)
 301   1          {
 302   2              P14 = 0;
 303   2          }
 304   1      }
 305          
 306          // ç¼“æ…¢è°ƒèŠ‚å ç©ºæ¯”ï¼ˆç¼“æ…¢æå‡å’Œç¼“æ…¢ä¸‹é™ï¼‰
 307          void Adaptive_Duty(void)
 308          {
 309   1      #if 0  // ç¼“æ…¢è°ƒèŠ‚å ç©ºæ¯”çš„ç‰ˆæœ¬ï¼š
                  if (c_duty > adjust_duty)
                  {
                      c_duty--;
                  }
                  if (c_duty < adjust_duty)
                  {
                      c_duty++;
                  }
                  set_pwm_duty(); // å‡½æ•°å†…éƒ¨ä¼šå°† c_duty çš„å€¼ä»£å…¥ç›¸å…³å¯„å­˜å™¨ä¸­
              
                  if (c_duty >= 5800)
                  {
              
                      // delay_ms(15); // æ—¶é—´è¿˜éœ€è¦æµ‹è¯•è°ƒæ•´ä¸€ä¸‹
                      delay_ms(7);
                  }
                  else
                  {
                      // delay_ms(5);
                      delay_ms(3);
                  }
              #endif // ç¼“æ…¢è°ƒèŠ‚å ç©ºæ¯”çš„ç‰ˆæœ¬
 332   1      
 333   1      #if 0 // ç«‹å³è°ƒèŠ‚å ç©ºæ¯”çš„ç‰ˆæœ¬ï¼š
              
                  // adjust_duty = adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY ; /* ä¸èƒ½è¿™ä¹ˆè®¡ç®—ï¼Œä¼šè¶Šæ¥
             -è¶Šå° */
                  c_duty = (u32)adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY; // adjust_duty * æ—‹é’®é™åˆ¶çš„å ç©
             -ºæ¯”ç³»æ•°
                  set_pwm_duty();                                                  // å‡½æ•°å†…éƒ¨ä¼šå°† c_duty çš„å€¼ä»
             -£å…¥ç›¸å…³å¯„å­˜å™¨ä¸­
              
                  if (0 == flag_is_in_power_on) // å¦‚æœä¸å¤„äºå¼€æœºç¼“å¯åŠ¨
                  {
                      if (c_duty <= KNOB_DIMMING_MIN_ADC_VAL) // å°äºæŸä¸ªå€¼ï¼Œç›´æ¥è¾“å‡º0%å ç©ºæ¯”ï¼Œå…³é—­PWMè¾
             -“å‡ºï¼Œå¼•è„šé…ç½®ä¸ºè¾“å‡ºæ¨¡å¼(å°½é‡å°äºç­‰äº2%çš„å ç©ºæ¯”å†ç­ç¯)
                      {
                          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡
             -ºæ¨¡å¼ï¼Œè¾“å‡ºä½ç”µå¹³
                          STMR_PWMEN &= ~0x01;          // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
                          FOUT_S16 = GPIO_FOUT_AF_FUNC; //
                          P16 = 1; // é«˜ç”µå¹³ä¸ºå…³ç¯(è¿˜æœªç¡®å®š)
                      }
                      else if (c_duty >= KNOB_DIMMING_MIN_ADC_VAL) // å¤§äºæŸä¸ªå€¼ï¼Œå†æ‰“å¼€PWMï¼Œå¼•è„šé…ç½®å›PW
             -M
                      {
                          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
C51 COMPILER V9.60.7.0   PWM                                                               05/05/2025 14:47:47 PAGE 7   

                          STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
                      }
                  }
              
              #if USE_MY_DEBUG
                  // printf(",c=%u,", c_duty);
              
                  {
                      static u8 cnt = 0;
                      cnt++;
                      if (cnt >= 200)
                      {
                          cnt = 0;
                          // printf("c_duty %u\n", c_duty);
                      }
                  }
              
              #endif
              
              #endif // ç«‹å³è°ƒèŠ‚å ç©ºæ¯”çš„ç‰ˆæœ¬
 371   1      
 372   1          /*
 373   1             å‡å°‘åˆ†çº§ä¹‹åï¼Œè¿˜æ˜¯ä¼šå‡ºç°ç›¸é‚»çš„çº§åˆ«ä¹‹é—´æ¥å›å˜åŒ–ï¼Œ
 374   1             è¿™é‡ŒåŠ ä¸Šç¼“æ…¢è°ƒèŠ‚å ç©ºæ¯”çš„åŠŸèƒ½
 375   1          */
 376   1      #if 1
 377   1          static u16 last_limited_max_pwm_duty = 0;
 378   1          static bit flag_is_first_update_limited = 1;                           // æ˜¯å¦ç¬¬ä¸€æ¬¡æ›´æ–°é™åˆ¶ç
             -š„æœ€å¤§å ç©ºæ¯”
 379   1          static bit flag_is_limited_change = 0;                                 // æ ‡å¿—ä½ï¼Œé™åˆ¶çš„æœ€å¤§å
             - ç©ºæ¯”æ˜¯å¦å‘ç”Ÿæ”¹å˜
 380   1          u16 tmp_duty = (u32)adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY; // adjust_duty * æ—‹é’®é™åˆ¶çš
             -„å ç©ºæ¯”ç³»æ•°
 381   1      
 382   1          if (flag_is_first_update_limited) // æ˜¯ç¬¬ä¸€æ¬¡æ›´æ–°é™åˆ¶çš„æœ€å¤§å ç©ºæ¯”
 383   1          {
 384   2              flag_is_first_update_limited = 0;
 385   2              last_limited_max_pwm_duty = limited_max_pwm_duty;
 386   2          }
 387   1      
 388   1          if (last_limited_max_pwm_duty != limited_max_pwm_duty)
 389   1          {
 390   2              flag_is_limited_change = 1; // è¡¨ç¤ºé™åˆ¶çš„æœ€å¤§å ç©ºæ¯”å‘ç”Ÿå˜åŒ–ï¼Œæ¥ä¸‹æ¥è¦ç¼“æ…¢è°ƒè
             -Š‚å ç©ºæ¯”
 391   2          }
 392   1      
 393   1          if (flag_is_limited_change) // å¦‚æœé™åˆ¶çš„æœ€å¤§å ç©ºæ¯”å‘ç”Ÿå˜åŒ–
 394   1          {
 395   2              if (flag_is_pwm_change_time_comes) // å¦‚æœæ›´æ–°å ç©ºæ¯”çš„æ—¶é—´åˆ°æ¥
 396   2              {
 397   3                  flag_is_pwm_change_time_comes = 0;
 398   3      
 399   3                  if (tmp_duty > c_duty)
 400   3                  {
 401   4                      c_duty++;
 402   4                  }
 403   3                  else if (tmp_duty < c_duty)
 404   3                  {
 405   4                      c_duty--;
 406   4                  }
 407   3                  else // å¦‚æœç›¸ç­‰
 408   3                  {
C51 COMPILER V9.60.7.0   PWM                                                               05/05/2025 14:47:47 PAGE 8   

 409   4                      last_limited_max_pwm_duty = limited_max_pwm_duty;
 410   4                      flag_is_limited_change = 0;
 411   4                  }
 412   3              }
 413   2          }
 414   1          else // å¦‚æœé™åˆ¶çš„æœ€å¤§å ç©ºæ¯”æœªå‘ç”Ÿå˜åŒ–
 415   1          {
 416   2              // c_duty = (u32)adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY; // adjust_duty * æ—‹é’®é™åˆ¶ç
             -š„å ç©ºæ¯”ç³»æ•°
 417   2              c_duty = tmp_duty; // å¦‚æœ limited_max_pwm_duty ä¸å˜ï¼Œç›´æ¥æ ¹æ® adjust_duty å˜åŒ–è€Œå˜åŒ
             -–
 418   2          }
 419   1      
 420   1          set_pwm_duty(); // å‡½æ•°å†…éƒ¨ä¼šå°† c_duty çš„å€¼ä»£å…¥ç›¸å…³å¯„å­˜å™¨ä¸­
 421   1      
 422   1          if (0 == flag_is_in_power_on) // å¦‚æœä¸å¤„äºå¼€æœºç¼“å¯åŠ¨
 423   1          {
 424   2              if (c_duty <= KNOB_DIMMING_MIN_ADC_VAL) // å°äºæŸä¸ªå€¼ï¼Œç›´æ¥è¾“å‡º0%å ç©ºæ¯”ï¼Œå…³é—­PWMè¾
             -“å‡ºï¼Œå¼•è„šé…ç½®ä¸ºè¾“å‡ºæ¨¡å¼(å°½é‡å°äºç­‰äº2%çš„å ç©ºæ¯”å†ç­ç¯)
 425   2              {
 426   3                  // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡
             -ºæ¨¡å¼ï¼Œè¾“å‡ºä½ç”µå¹³
 427   3                  STMR_PWMEN &= ~0x01;          // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
 428   3                  FOUT_S16 = GPIO_FOUT_AF_FUNC; //
 429   3                  P16 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯(è¿˜æœªç¡®å®š)
 430   3              }
 431   2              else if (c_duty >= KNOB_DIMMING_MIN_ADC_VAL) // å¤§äºæŸä¸ªå€¼ï¼Œå†æ‰“å¼€PWMï¼Œå¼•è„šé…ç½®å›PW
             -M
 432   2              {
 433   3                  FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
 434   3                  STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
 435   3              }
 436   2          }
 437   1      
 438   1      
 439   1          // printf("c_duty %u\n", c_duty);
 440   1      #endif //
 441   1      }
 442          
 443          // void pwm_adjust(void)
 444          // {
 445          
 446          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1425    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    624       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
