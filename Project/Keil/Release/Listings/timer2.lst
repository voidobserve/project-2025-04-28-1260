C51 COMPILER V9.60.7.0   TIMER2                                                            05/19/2025 14:01:26 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIMER2
OBJECT MODULE PLACED IN .\Release\Objects\timer2.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\timer2.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\timer2.lst) OBJECT(.\Rel
                    -ease\Objects\timer2.obj)

line level    source

   1          #include "timer2.h"
   2          #define TIMER2_PEROID_VAL (SYSCLK / 128 / 10000 - 1) // å‘¨æœŸå€¼=ç³»ç»Ÿæ—¶é’Ÿ/åˆ†é¢‘/é¢‘ç‡ - 1
   3          
   4          extern volatile bit flag_is_in_power_on; // æ˜¯å¦å¤„äºå¼€æœºç¼“å¯åŠ¨
   5          
   6          static volatile u16 pwm_duty_add_cnt; // ç”¨äºæ§åˆ¶pwmå¢åŠ çš„æ—¶é—´è®¡æ•°
   7          static volatile u16 pwm_duty_sub_cnt; // ç”¨äºæ§åˆ¶pwmé€’å‡çš„æ—¶é—´è®¡æ•°
   8          
   9          volatile bit flag_is_pwm_add_time_comes = 0; // æ ‡å¿—ä½ï¼Œpwmå ç©ºæ¯”é€’å¢æ—¶é—´åˆ°æ¥
  10          volatile bit flag_is_pwm_sub_time_comes = 0; // æ ‡å¿—ä½ï¼Œpwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
  11          
  12          static volatile u16 pwm_duty_change_cnt = 0;    // ç”¨äºæ§åˆ¶pwmå˜åŒ–çš„æ—¶é—´è®¡æ•°ï¼ˆç”¨åœ¨æ—‹é’®è°ƒè
             -Š‚çš„PWMå ç©ºæ¯”ä¸­ï¼‰
  13          // volatile bit flag_is_pwm_change_time_comes = 0; // æ ‡å¿—ä½ï¼Œpwmå˜åŒ–æ—¶é—´åˆ°æ¥ï¼ˆç”¨åœ¨æ—‹é’®è°ƒè
             -Š‚çš„PWMå ç©ºæ¯”ä¸­ï¼‰
  14          
  15          void timer2_config(void)
  16          {
  17   1          __EnableIRQ(TMR2_IRQn); // ä½¿èƒ½timer2ä¸­æ–­
  18   1          IE_EA = 1;              // ä½¿èƒ½æ€»ä¸­æ–­
  19   1      
  20   1          // è®¾ç½®timer2çš„è®¡æ•°åŠŸèƒ½ï¼Œé…ç½®ä¸€ä¸ªé¢‘ç‡ä¸º1kHzçš„ä¸­æ–­
  21   1          TMR_ALLCON = TMR2_CNT_CLR(0x1);                               // æ¸…é™¤è®¡æ•°å€¼
  22   1          TMR2_PRH = TMR_PERIOD_VAL_H((TIMER2_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  23   1          TMR2_PRL = TMR_PERIOD_VAL_L((TIMER2_PEROID_VAL >> 0) & 0xFF);
  24   1          TMR2_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // è®¡æ•°ç­‰äºå‘¨æœŸæ—¶å
             -…è®¸å‘ç”Ÿä¸­æ–­
  25   1          TMR2_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x1); // é€‰æ‹©ç³»ç»Ÿæ—¶é’Ÿï¼Œ1
             -28åˆ†é¢‘ï¼Œè®¡æ•°æ¨¡å¼
  26   1      }
  27          
  28          // å®šæ—¶å™¨ ä¸­æ–­æœåŠ¡å‡½æ•°
  29          void TIMR2_IRQHandler(void) interrupt TMR2_IRQn
  30          {
  31   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
  32   1          __IRQnIPnPush(TMR2_IRQn);
  33   1      
  34   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
  35   1      
  36   1          // å‘¨æœŸä¸­æ–­
  37   1          if (TMR2_CONH & TMR_PRD_PND(0x1)) // çº¦100usè§¦å‘ä¸€æ¬¡ä¸­æ–­
  38   1          {
  39   2              TMR2_CONH |= TMR_PRD_PND(0x1); // æ¸…é™¤pending
  40   2      
  41   2              // tmr2_cnt++;
  42   2              // P13 = ~P13; // æµ‹è¯•ä¸­æ–­è§¦å‘å‘¨æœŸ
  43   2      
  44   2              pwm_duty_add_cnt++;
  45   2              pwm_duty_sub_cnt++;
  46   2              pwm_duty_change_cnt++;
  47   2      
  48   2              if (pwm_duty_sub_cnt >= 13) // 1300usï¼Œ1.3ms
  49   2              // if (pwm_duty_sub_cnt >= 50)
C51 COMPILER V9.60.7.0   TIMER2                                                            05/19/2025 14:01:26 PAGE 2   

  50   2              {
  51   3                  pwm_duty_sub_cnt = 0;
  52   3                  flag_is_pwm_sub_time_comes = 1;
  53   3              }
  54   2      
  55   2              // if (pwm_duty_add_cnt >= 133) // 13300us, 13.3ms
  56   2              if (pwm_duty_add_cnt >= 13) //
  57   2              {
  58   3                  pwm_duty_add_cnt = 0;
  59   3                  flag_is_pwm_add_time_comes = 1;
  60   3              }
  61   2      
  62   2      #if 1
  63   2              // if (pwm_duty_change_cnt >= 10) // 1000us,1ms
  64   2              if (pwm_duty_change_cnt >= 5) // 500us
  65   2              {
  66   3      
  67   3                  pwm_duty_change_cnt = 0;
  68   3                  // flag_is_pwm_change_time_comes = 1;
  69   3      
  70   3      #if 1
  71   3                  if (0 == flag_is_in_power_on) // ä¸å¤„äºå¼€æœºç¼“å¯åŠ¨ï¼Œæ‰ä½¿èƒ½PWMå ç©ºæ¯”è°ƒèŠ‚
  72   3                  {
  73   4                      if (limited_adjust_pwm_duty > c_duty)
  74   4                      {
  75   5                          c_duty++;
  76   5      
  77   5      
  78   5                          // // if ((limited_adjust_pwm_duty - c_duty) < 20) // åœ¨æ—‹é’®æŒ¡ä½20%æ—¶ï¼Œç¯å…‰é—
             -ªçƒæœ€æ˜æ˜¾
  79   5                          // if ((limited_adjust_pwm_duty - c_duty) < 50) // æ—‹é’®æŒ¡ä½åœ¨10%é™„è¿‘æ—¶ï¼Œç¯å…
             -‰ä¼šæœ‰å¾®å¾®é—ªçƒ
  80   5                          // // if ((limited_adjust_pwm_duty - c_duty) < 80) //  
  81   5                          // {
  82   5                          //     if (pwm_duty_change_cnt >= 10000) // 1s
  83   5                          //     {
  84   5                          //         pwm_duty_change_cnt = 0;
  85   5                          //         c_duty++;
  86   5                          //     }
  87   5                          // }
  88   5                          // else
  89   5                          // {
  90   5                          //     if (pwm_duty_change_cnt >= 5) // 500us
  91   5                          //     {
  92   5                          //         pwm_duty_change_cnt = 0;
  93   5                          //         c_duty++;
  94   5                          //     }
  95   5                          // }
  96   5                      }
  97   4                      else if (limited_adjust_pwm_duty < c_duty)
  98   4                      {
  99   5                          c_duty--;
 100   5      
 101   5                          // // if ((c_duty - limited_adjust_pwm_duty) < 20) // åœ¨æ—‹é’®æŒ¡ä½20%æ—¶ï¼Œç¯å…‰é—
             -ªçƒæœ€æ˜æ˜¾
 102   5                          // if ((c_duty - limited_adjust_pwm_duty) < 50) // æ—‹é’®æŒ¡ä½åœ¨10%é™„è¿‘æ—¶ï¼Œç¯å…
             -‰ä¼šæœ‰å¾®å¾®é—ªçƒ
 103   5                          // // if ((c_duty - limited_adjust_pwm_duty) < 80) // 
 104   5                          // {
 105   5                          //     if (pwm_duty_change_cnt >= 10000) // 1s
 106   5                          //     {
 107   5                          //         pwm_duty_change_cnt = 0;
C51 COMPILER V9.60.7.0   TIMER2                                                            05/19/2025 14:01:26 PAGE 3   

 108   5                          //         c_duty--;
 109   5                          //     }
 110   5                          // }
 111   5                          // else
 112   5                          // {
 113   5                          //     if (pwm_duty_change_cnt >= 5) // 500us
 114   5                          //     {
 115   5                          //         pwm_duty_change_cnt = 0;
 116   5                          //         c_duty--;
 117   5                          //     }
 118   5                          // }
 119   5                      }
 120   4                      else // å¦‚æœç›¸ç­‰
 121   4                      {
 122   5                          // last_limited_max_pwm_duty = limited_max_pwm_duty;
 123   5                          // flag_is_knob_change = 0;
 124   5                          // pwm_duty_change_cnt = 0;
 125   5                      }
 126   4      
 127   4                      set_pwm_duty(); // å‡½æ•°å†…éƒ¨ä¼šå°† c_duty çš„å€¼ä»£å…¥ç›¸å…³å¯„å­˜å™¨ä¸­
 128   4      
 129   4                      // if (c_duty <= KNOB_DIMMING_MIN_ADC_VAL) // å°äºæŸä¸ªå€¼ï¼Œç›´æ¥è¾“å‡º0%å ç©ºæ¯”ï¼Œ
             -å…³é—­PWMè¾“å‡ºï¼Œå¼•è„šé…ç½®ä¸ºè¾“å‡ºæ¨¡å¼(å°½é‡å°äºç­‰äº2%çš„å ç©ºæ¯”å†ç­ç¯)
 130   4                      if (c_duty <= 0) // å°äºæŸä¸ªå€¼ï¼Œç›´æ¥è¾“å‡º0%å ç©ºæ¯”ï¼Œå…³é—­PWMè¾“å‡ºï¼Œå¼•è„šé…
             -ç½®ä¸ºè¾“å‡ºæ¨¡å¼(å°½é‡å°äºç­‰äº2%çš„å ç©ºæ¯”å†ç­ç¯)
 131   4                      {
 132   5                          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®
             -å›è¾“å‡ºæ¨¡å¼ï¼Œè¾“å‡ºä½ç”µå¹³
 133   5                          STMR_PWMEN &= ~0x01;          // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
 134   5                          FOUT_S16 = GPIO_FOUT_AF_FUNC; //
 135   5                          P16 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 136   5                      }
 137   4                      // else if (c_duty >= KNOB_DIMMING_MIN_ADC_VAL) // å¤§äºæŸä¸ªå€¼ï¼Œå†æ‰“å¼€PWMï¼Œå¼•è„š
             -é…ç½®å›PWM
 138   4                      else if (c_duty >= 0) // å¤§äºæŸä¸ªå€¼ï¼Œå†æ‰“å¼€PWMï¼Œå¼•è„šé…ç½®å›PWM
 139   4                      {
 140   5                          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
 141   5                          STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
 142   5                      }
 143   4                  } // if (0 == flag_is_in_power_on) // ä¸å¤„äºå¼€æœºç¼“å¯åŠ¨ï¼Œæ‰ä½¿èƒ½PWMå ç©ºæ¯”è°ƒèŠ‚
 144   3      #endif
 145   3      
 146   3      #if 0
                          // printf("c_duty %u\n", c_duty);
                          // printf(",c=%u\n", c_duty);
              #endif
 150   3              }
 151   2      
 152   2      #endif
 153   2          }
 154   1      
 155   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 156   1          __IRQnIPnPop(TMR2_IRQn);
 157   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    340    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      6    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.60.7.0   TIMER2                                                            05/19/2025 14:01:26 PAGE 4   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
