C51 COMPILER V9.60.7.0   TIMER2                                                            05/06/2025 17:37:56 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIMER2
OBJECT MODULE PLACED IN .\Release\Objects\timer2.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\timer2.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\timer2.lst) OBJECT(.\Rel
                    -ease\Objects\timer2.obj)

line level    source

   1          #include "timer2.h"
   2          #define TIMER2_PEROID_VAL (SYSCLK / 128 / 10000 - 1) // Âë®ÊúüÂÄº=Á≥ªÁªüÊó∂Èíü/ÂàÜÈ¢ë/È¢ëÁéá - 1
   3          
   4          // volatile u16 tmr2_cnt = 0;
   5          
   6          static volatile u16 pwm_duty_add_cnt; // Áî®‰∫éÊéßÂà∂pwmÂ¢ûÂä†ÁöÑÊó∂Èó¥ËÆ°Êï∞
   7          static volatile u16 pwm_duty_sub_cnt; // Áî®‰∫éÊéßÂà∂pwmÈÄíÂáèÁöÑÊó∂Èó¥ËÆ°Êï∞
   8          
   9          volatile bit flag_is_pwm_add_time_comes = 0; // Ê†áÂøó‰ΩçÔºåpwmÂç†Á©∫ÊØîÈÄíÂ¢ûÊó∂Èó¥Âà∞Êù•
  10          volatile bit flag_is_pwm_sub_time_comes = 0; // Ê†áÂøó‰ΩçÔºåpwmÂç†Á©∫ÊØîÈÄíÂáèÊó∂Èó¥Âà∞Êù•
  11          
  12          static volatile u8 pwm_duty_change_cnt = 0;     // Áî®‰∫éÊéßÂà∂pwmÂèòÂåñÁöÑÊó∂Èó¥ËÆ°Êï∞ÔºàÁî®Âú®ÊóãÈíÆË∞ÉË
             -äÇÁöÑPWMÂç†Á©∫ÊØî‰∏≠Ôºâ
  13          volatile bit flag_is_pwm_change_time_comes = 0; // Ê†áÂøó‰ΩçÔºåpwmÂèòÂåñÊó∂Èó¥Âà∞Êù•ÔºàÁî®Âú®ÊóãÈíÆË∞ÉËäÇÁ
             -öÑPWMÂç†Á©∫ÊØî‰∏≠Ôºâ
  14          
  15          void timer2_config(void)
  16          {
  17   1          __EnableIRQ(TMR2_IRQn); // ‰ΩøËÉΩtimer2‰∏≠Êñ≠
  18   1          IE_EA = 1;              // ‰ΩøËÉΩÊÄª‰∏≠Êñ≠
  19   1      
  20   1          // ËÆæÁΩÆtimer2ÁöÑËÆ°Êï∞ÂäüËÉΩÔºåÈÖçÁΩÆ‰∏Ä‰∏™È¢ëÁéá‰∏∫1kHzÁöÑ‰∏≠Êñ≠
  21   1          TMR_ALLCON = TMR2_CNT_CLR(0x1);                               // Ê∏ÖÈô§ËÆ°Êï∞ÂÄº
  22   1          TMR2_PRH = TMR_PERIOD_VAL_H((TIMER2_PEROID_VAL >> 8) & 0xFF); // Âë®ÊúüÂÄº
  23   1          TMR2_PRL = TMR_PERIOD_VAL_L((TIMER2_PEROID_VAL >> 0) & 0xFF);
  24   1          TMR2_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // ËÆ°Êï∞Á≠â‰∫éÂë®ÊúüÊó∂Â
             -ÖÅËÆ∏ÂèëÁîü‰∏≠Êñ≠
  25   1          TMR2_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x1); // ÈÄâÊã©Á≥ªÁªüÊó∂ÈíüÔºå1
             -28ÂàÜÈ¢ëÔºåËÆ°Êï∞Ê®°Âºè
  26   1      }
  27          
  28          // ÂÆöÊó∂Âô® ‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞
  29          void TIMR2_IRQHandler(void) interrupt TMR2_IRQn
  30          {
  31   1          // ËøõÂÖ•‰∏≠Êñ≠ËÆæÁΩÆIPÔºå‰∏çÂèØÂà†Èô§
  32   1          __IRQnIPnPush(TMR2_IRQn);
  33   1      
  34   1          // ---------------- Áî®Êà∑ÂáΩÊï∞Â§ÑÁêÜ -------------------
  35   1      
  36   1          // Âë®Êúü‰∏≠Êñ≠
  37   1          if (TMR2_CONH & TMR_PRD_PND(0x1)) // Á∫¶100usËß¶Âèë‰∏ÄÊ¨°‰∏≠Êñ≠
  38   1          {
  39   2              TMR2_CONH |= TMR_PRD_PND(0x1); // Ê∏ÖÈô§pending
  40   2      
  41   2              // tmr2_cnt++;
  42   2              // P13 = ~P13; // ÊµãËØï‰∏≠Êñ≠Ëß¶ÂèëÂë®Êúü
  43   2      
  44   2              pwm_duty_add_cnt++;
  45   2              pwm_duty_sub_cnt++;
  46   2              pwm_duty_change_cnt++;
  47   2      
  48   2              if (pwm_duty_sub_cnt >= 13) // 1300usÔºå1.3ms
  49   2              // if (pwm_duty_sub_cnt >= 50)
C51 COMPILER V9.60.7.0   TIMER2                                                            05/06/2025 17:37:56 PAGE 2   

  50   2              {
  51   3                  pwm_duty_sub_cnt = 0;
  52   3                  flag_is_pwm_sub_time_comes = 1;
  53   3              }
  54   2      
  55   2              // if (pwm_duty_add_cnt >= 133) // 13300us, 13.3ms
  56   2              if (pwm_duty_add_cnt >= 13) //
  57   2              {
  58   3                  pwm_duty_add_cnt = 0;
  59   3                  flag_is_pwm_add_time_comes = 1;
  60   3              }
  61   2      
  62   2              // if (pwm_duty_change_cnt >= 10) // 1000us,1ms
  63   2              if (pwm_duty_change_cnt >= 5) //
  64   2              {
  65   3                  u16 tmp_duty = (u32)adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY; // adjust_duty * ÊóãÈíÆ
             -ÈôêÂà∂ÁöÑÂç†Á©∫ÊØîÁ≥ªÊï∞
  66   3      
  67   3                  pwm_duty_change_cnt = 0;
  68   3                  // flag_is_pwm_change_time_comes = 1;
  69   3      
  70   3      #if 1
  71   3      
  72   3                  if (tmp_duty > c_duty)
  73   3                  {
  74   4                      c_duty++;
  75   4                  }
  76   3                  else if (tmp_duty < c_duty)
  77   3                  {
  78   4                      c_duty--;
  79   4                  }
  80   3                  else // Â¶ÇÊûúÁõ∏Á≠â
  81   3                  {
  82   4                      // last_limited_max_pwm_duty = limited_max_pwm_duty;
  83   4                      // flag_is_knob_change = 0;
  84   4                  }
  85   3      
  86   3                  set_pwm_duty(); // ÂáΩÊï∞ÂÜÖÈÉ®‰ºöÂ∞Ü c_duty ÁöÑÂÄº‰ª£ÂÖ•Áõ∏ÂÖ≥ÂØÑÂ≠òÂô®‰∏≠
  87   3      
  88   3                  // if (c_duty <= KNOB_DIMMING_MIN_ADC_VAL) // Â∞è‰∫éÊüê‰∏™ÂÄºÔºåÁõ¥Êé•ËæìÂá∫0%Âç†Á©∫ÊØîÔºåÂÖ≥È
             -ó≠PWMËæìÂá∫ÔºåÂºïËÑöÈÖçÁΩÆ‰∏∫ËæìÂá∫Ê®°Âºè(Â∞ΩÈáèÂ∞è‰∫éÁ≠â‰∫é2%ÁöÑÂç†Á©∫ÊØîÂÜçÁÅ≠ÁÅØ)
  89   3                  if (c_duty <= 0) // Â∞è‰∫éÊüê‰∏™ÂÄºÔºåÁõ¥Êé•ËæìÂá∫0%Âç†Á©∫ÊØîÔºåÂÖ≥Èó≠PWMËæìÂá∫ÔºåÂºïËÑöÈÖçÁΩÆ
             -‰∏∫ËæìÂá∫Ê®°Âºè(Â∞ΩÈáèÂ∞è‰∫éÁ≠â‰∫é2%ÁöÑÂç†Á©∫ÊØîÂÜçÁÅ≠ÁÅØ)
  90   3                  {
  91   4                      // Áõ¥Êé•ËæìÂá∫0%ÁöÑÂç†Á©∫ÊØîÔºåÂèØËÉΩ‰ºöÊúâ‰∫õË∑≥Âä®ÔºåÈúÄË¶ÅÂ∞ÜÂØπÂ∫îÁöÑÂºïËÑöÈÖçÁΩÆÂõûË
             -æìÂá∫Ê®°ÂºèÔºåËæìÂá∫‰ΩéÁîµÂπ≥
  92   4                      STMR_PWMEN &= ~0x01;          // ‰∏ç‰ΩøËÉΩPWM0ÁöÑËæìÂá∫
  93   4                      FOUT_S16 = GPIO_FOUT_AF_FUNC; //
  94   4                      P16 = 1;                      // È´òÁîµÂπ≥‰∏∫ÂÖ≥ÁÅØ
  95   4                  }
  96   3                  // else if (c_duty >= KNOB_DIMMING_MIN_ADC_VAL) // Â§ß‰∫éÊüê‰∏™ÂÄºÔºåÂÜçÊâìÂºÄPWMÔºåÂºïËÑöÈÖçÁ
             -ΩÆÂõûPWM
  97   3                  else if (c_duty >= 0) // Â§ß‰∫éÊüê‰∏™ÂÄºÔºåÂÜçÊâìÂºÄPWMÔºåÂºïËÑöÈÖçÁΩÆÂõûPWM
  98   3                  {
  99   4                      FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
 100   4                      STMR_PWMEN |= 0x01;                // ‰ΩøËÉΩPWM0ÁöÑËæìÂá∫
 101   4                  }
 102   3      
 103   3                  // printf("c_duty %u\n", c_duty);
 104   3                  // printf(",c=%u\n", c_duty);
 105   3      #endif
 106   3              }
C51 COMPILER V9.60.7.0   TIMER2                                                            05/06/2025 17:37:56 PAGE 3   

 107   2          }
 108   1      
 109   1          // ÈÄÄÂá∫‰∏≠Êñ≠ËÆæÁΩÆIPÔºå‰∏çÂèØÂà†Èô§
 110   1          __IRQnIPnPop(TMR2_IRQn);
 111   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    353    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
